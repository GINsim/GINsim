package fr.univmrs.tagc.GINsim.export.regulatoryGraph;

import java.io.FileWriter;
import java.io.IOException;
import java.text.DateFormat;
import java.util.*;

import javax.swing.JComponent;

import fr.univmrs.tagc.GINsim.data.GsDirectedEdge;
import fr.univmrs.tagc.GINsim.export.GsAbstractExport;
import fr.univmrs.tagc.GINsim.export.GsExportConfig;
import fr.univmrs.tagc.GINsim.global.GsEnv;
import fr.univmrs.tagc.GINsim.graph.GsGraph;
import fr.univmrs.tagc.GINsim.gui.GsPluggableActionDescriptor;
import fr.univmrs.tagc.GINsim.regulatoryGraph.GsRegulatoryGraph;
import fr.univmrs.tagc.GINsim.regulatoryGraph.GsRegulatoryVertex;
import fr.univmrs.tagc.GINsim.regulatoryGraph.OmddNode;
import fr.univmrs.tagc.GINsim.regulatoryGraph.initialState.GsInitialState;
import fr.univmrs.tagc.GINsim.regulatoryGraph.mutant.GsRegulatoryMutantDef;
import fr.univmrs.tagc.common.GsException;
import fr.univmrs.tagc.common.widgets.StackDialog;

/**
 * Encode a graph to SMV format.
 */
public class GsSMVExport extends GsAbstractExport {
	static transient Map hash;

	public GsSMVExport() {
		id = "SMV";
		extension = ".smv";
		filter = new String[] { "smv" };
		filterDescr = "SMV files";
	}

	protected void doExport(GsExportConfig config) {
		encode((GsRegulatoryGraph) config.getGraph(), config.getFilename(),
				(GsSMVexportConfig) config.getSpecificConfig());
	}

	public GsPluggableActionDescriptor[] getT_action(int actionType,
			GsGraph graph) {
		if (graph instanceof GsRegulatoryGraph) {
			return new GsPluggableActionDescriptor[] { new GsPluggableActionDescriptor(
					"STR_modelChecker", "STR_modelCheckerExport_descr", null,
					this, ACTION_EXPORT, 0) };
		}
		return null;
	}

	public boolean needConfig(GsExportConfig config) {
		return true;
	}

	protected JComponent getConfigPanel(GsExportConfig config,
			StackDialog dialog) {
		return new GsSMVExportConfigPanel(config, dialog, true, false);
	}

	private static String getInitState(Object vertex, Map m) {
		List v = (List) m.get(vertex);
		if (v != null && v.size() > 0) {
			String s = "" + v.get(0);
			if (v.size() > 1) {
				s = "{" + s;
				for (int j = 1; j < v.size(); j++) {
					s += "," + v.get(j);
				}
				s += "}";
			}
			return s;
		}
		return null;
	}

	/**
	 * @param graph
	 * @param selectedOnly
	 * @param fileName
	 * @param config
	 *            store the configuration
	 */
	public static void encode(GsRegulatoryGraph graph, String fileName,
			GsSMVexportConfig config) {
		hash = new HashMap();

		DateFormat dateformat = DateFormat.getDateTimeInstance(DateFormat.LONG,
				DateFormat.LONG);
		String date = dateformat.format(new Date());
		try {
			FileWriter out = new FileWriter(fileName);
			int type = config.getType();
			Iterator it = config.getInitialState().keySet().iterator();
			Map m_initstates;
			if (it.hasNext()) {
				m_initstates = ((GsInitialState) it.next()).getMap();
			} else {
				m_initstates = new HashMap();
			}
			if (m_initstates == null) {
				m_initstates = new HashMap();
			}

			GsRegulatoryMutantDef mutant = (GsRegulatoryMutantDef)config.store.getObject(0);
			out.write("-- SMV file generated by GINsim - " + date + "\n\n");

			List nodeOrder = graph.getNodeOrder();
			String[] t_regulators = new String[nodeOrder.size()];
			int[] t_cst = new int[nodeOrder.size()];
			GsRegulatoryVertex[] t_vertex = new GsRegulatoryVertex[nodeOrder
					.size()];
			OmddNode[] t_tree = graph.getAllTrees(true);
			if (mutant != null) {
				mutant.apply(t_tree, graph);
			}

			switch (config.type) { // synchronous
			case GsSMVexportConfig.CFG_SYNC:
				out.write("\nMODULE main\n");

				out.write("  VAR\n");

				for (int i = 0; i < t_vertex.length; i++) {
					GsRegulatoryVertex vertex = (GsRegulatoryVertex) nodeOrder
							.get(i);
					t_vertex[i] = vertex;
					t_regulators[i] = vertex.getId();
					String s_levels = "0";

					for (int j = 1; j <= vertex.getMaxValue(); j++) {
						s_levels += ", " + j;
					}
					out.write("  " + vertex.getId() + " : {" + s_levels
							+ "};\n");
					// if not in the boolean case, add a temporary variable to
					// (in/de)crease smoothly
					if (vertex.getMaxValue() > 1) {
						out.write("  " + vertex.getId() + "_nlevel : {"
								+ s_levels + "};\n");
					}
				}

				out.write("  ASSIGN\n");
				for (int i = 0; i < nodeOrder.size(); i++) {
					String s_init = getInitState(nodeOrder.get(i), m_initstates);
					if (s_init == null) {
						out
								.write("--    init(" + t_regulators[i]
										+ ") := 0;\n");
					} else {
						out.write("      init(" + t_regulators[i] + ") := "
								+ s_init + ";\n");
					}
				}
				for (int i = 0; i < nodeOrder.size(); i++) {
					GsRegulatoryVertex vertex = t_vertex[i];
					if (vertex.getMaxValue() > 1) {
						out.write("  " + vertex.getId() + "_nlevel := \n");
					} else {
						out.write("  next(" + vertex.getId() + ") := \n");
					}
					out.write("      case\n");
					for (int j = 0; j < t_cst.length; j++) {
						t_cst[j] = -1;
					}
					node2SMV(t_tree[i], out, t_vertex, t_cst, i, type);
					out.write("      esac;\n");

					if (vertex.getMaxValue() > 1) {
						out.write("    next(" + vertex.getId() + ") := \n");
						out.write("      case\n");
						out.write("        (" + vertex.getId() + "_nlevel > "
								+ vertex.getId() + ") : " + vertex.getId()
								+ " + 1;\n");
						out.write("        (" + vertex.getId() + "_nlevel < "
								+ vertex.getId() + ") : " + vertex.getId()
								+ " - 1;\n");
						out.write("        (" + vertex.getId() + "_nlevel = "
								+ vertex.getId() + ") : " + vertex.getId()
								+ ";\n");
						out.write("      esac;\n");
					}
				}
				break;

			case GsSMVexportConfig.CFG_ASYNC: // asynchronous
				for (int i = 0; i < t_vertex.length; i++) {
					GsRegulatoryVertex vertex = (GsRegulatoryVertex) nodeOrder
							.get(i);
					t_vertex[i] = vertex;
					t_regulators[i] = vertex.getId();
				}

				for (int i = 0; i < nodeOrder.size(); i++) {
					GsRegulatoryVertex vertex = t_vertex[i];
					// get regulators
					List l_regulators = graph.getGraphManager()
							.getIncomingEdges(vertex);
					String s_regulators = "";
					if (l_regulators.size() > 0) {
						for (int j = 0; j < l_regulators.size(); j++) {
							GsRegulatoryVertex regulator = (GsRegulatoryVertex) ((GsDirectedEdge) l_regulators
									.get(j)).getSourceVertex();
							if (regulator != vertex) {
								s_regulators += regulator + ", ";
							}
						}
						// always add a self-control (for mutants...)
						s_regulators += "" + vertex;
					}
					t_regulators[i] = "    " + vertex.getId() + "\t: process _"
							+ vertex.getId() + "(" + s_regulators + ");\n";

					out.write("MODULE _" + vertex.getId() + "(" + s_regulators
							+ ")\n");
					String s_levels = "0";
					for (int j = 1; j <= vertex.getMaxValue(); j++) {
						s_levels += ", " + j;
					}

					out.write("  VAR\n    level : {" + s_levels + "};\n");
					// if not in the boolean case, add a temporary variable to
					// (in/de)crease smoothly
					if (vertex.getMaxValue() > 1) {
						out.write("    nlevel : {" + s_levels + "};\n");
					}
					out.write("  ASSIGN\n");
					String s_init = getInitState(nodeOrder.get(i), m_initstates);
					if (s_init == null) {
						out.write("--    init(level) := 0;\n");
					} else {
						out.write("    init(level) := " + s_init + ";\n");
					}
					if (vertex.getMaxValue() > 1) {
						out.write("    nlevel := \n");
					} else {
						out.write("    next(level) := \n");
					}
					out.write("      case\n");
					for (int j = 0; j < t_cst.length; j++) {
						t_cst[j] = -1;
					}
					node2SMV(t_tree[i], out, t_vertex, t_cst, i, type);
					out.write("      esac;\n");

					if (vertex.getMaxValue() > 1) {
						out.write("    next(level) := \n");
						out.write("      case\n");
						out.write("        (nlevel > level) : level + 1;\n");
						out.write("        (nlevel < level) : level - 1;\n");
						out.write("        (nlevel = level) : level;\n");
						out.write("      esac;\n");
					}
					out.write("FAIRNESS running\n\n");
				}

				out.write("\nMODULE main\n");
				out.write("  VAR\n");
				for (int i = 0; i < t_regulators.length; i++) {
					out.write(t_regulators[i]);
				}

				// ask for one stable state
				if (true) {
					out.write("\n--SPEC !EF (");
					for (int i = 0; i < t_vertex.length; i++) {
						out.write(" (");
						GsRegulatoryVertex vertex = t_vertex[i];
						for (int j = 0; j <= vertex.getMaxValue(); j++) {
							if (j != 0) {
								out.write("  ");
							}
							out.write("(" + vertex + ".level = " + j
									+ " &  AX " + vertex + ".level = " + j
									+ ")");
							if (j < vertex.getMaxValue()) {
								out.write(" |");
							}
						}
						out.write(")");
						if (i < t_vertex.length - 1) {
							out.write(" &");
						}
					}
					out.write(")\n");
				}
				break;
			// new synchronous with variable _R
			default:
				out.write("\nMODULE main\n");

				out.write("  VAR\n");
				int cmp = 0;
				for (int i = 0; i < t_vertex.length; i++) {
					GsRegulatoryVertex vertex = (GsRegulatoryVertex) nodeOrder
							.get(i);
					t_vertex[i] = vertex;
					t_regulators[i] = vertex.getId();
					String s_levels = "0";
					cmp++;

					for (int j = 1; j <= vertex.getMaxValue(); j++) {
						s_levels += ", " + j;

					}
					out.write("  " + vertex.getId() + " : {" + s_levels
							+ "};\n");

					// if not in the boolean case, add a temporary variable to
					// (in/de)crease smoothly
					if (vertex.getMaxValue() > 1) {
						out.write("  " + vertex.getId() + "_nlevel : {"
								+ s_levels + "};\n");
					}
				}
				// write the value of variable _R
				out.write("  _R : {");
				for (int a = 0; a < cmp - 1; a++) {
					out.write(a + ", ");
				}
				out.write(cmp - 1 + "};\n");

				out.write("  ASSIGN\n");
				for (int i = 0; i < nodeOrder.size(); i++) {
					String s_init = getInitState(nodeOrder.get(i), m_initstates);
					if (s_init == null) {
						out
								.write("--    init(" + t_regulators[i]
										+ ") := 0;\n");
					} else {
						out.write("      init(" + t_regulators[i] + ") := "
								+ s_init + ";\n");
					}
				}
				// write the next for variable _R
				out.write("  next(_R) := {");
				for (int a = 0; a < cmp - 1; a++) {
					out.write(a + ", ");
				}
				out.write(cmp - 1 + "};\n");

				for (int i = 0; i < nodeOrder.size(); i++) {
					GsRegulatoryVertex vertex = t_vertex[i];
					if (vertex.getMaxValue() > 1) {
						out.write("  " + vertex.getId() + "_nlevel := \n");
					} else {
						out.write("  next(" + vertex.getId() + ") := \n");
					}
					out.write("      case\n");
					for (int j = 0; j < t_cst.length; j++) {
						t_cst[j] = -1;
					}
					out.write("        (_R != " + i + ") : " + vertex.getId()
							+ ";\n");
					node2SMV(t_tree[i], out, t_vertex, t_cst, i, type);
					out.write("      esac;\n");

					if (vertex.getMaxValue() > 1) {
						out.write("    next(" + vertex.getId() + ") := \n");
						out.write("      case\n");
						out.write("        (" + vertex.getId() + "_nlevel > "
								+ vertex.getId() + ") : " + vertex.getId()
								+ " + 1;\n");
						out.write("        (" + vertex.getId() + "_nlevel < "
								+ vertex.getId() + ") : " + vertex.getId()
								+ " - 1;\n");
						out.write("        (" + vertex.getId() + "_nlevel = "
								+ vertex.getId() + ") : " + vertex.getId()
								+ ";\n");
						out.write("      esac;\n");
					}
				}
				break;

			}
			// add the test
			if (config.thetest != null) {
				out.write("\n");
				out.write(config.thetest + "\n");
			}

			// Close main tags
			out.close();

		} catch (IOException e) {
			GsEnv.error(new GsException(GsException.GRAVITY_ERROR, e
					.getLocalizedMessage()), null);
		}
	}

	static private void node2SMV(OmddNode node, FileWriter out,
			GsRegulatoryVertex[] t_names, int[] t_cst, int index, int type)
			throws IOException {
		if (node.next == null) // this is a leaf, write the constraint
		{
			String s = "";
			String s_assign = type != GsSMVexportConfig.CFG_ASYNC ? " = "
					: ".level = ";

			for (int i = 0; i < t_cst.length; i++) {

				if (t_cst[i] != -1) {
					if (type != GsSMVexportConfig.CFG_ASYNC || i != index) {
						s += "(" + t_names[i] + s_assign + t_cst[i] + ") & ";
					} else {
						s += "(level = " + t_cst[i] + ") & ";
					}
				}
			}
			if ("".equals(s)) {
				s = "1 ";
			} else {
				s = s.substring(0, s.length() - 2);
			}
			// FIXME: replace node.value with smart incremental move
			out.write("        " + s + " : " + node.value + ";\n");
			return;
		}
		for (int i = 0; i < node.next.length; i++) {
			t_cst[node.level] = i;
			node2SMV(node.next[i], out, t_names, t_cst, index, type);
		}
		t_cst[node.level] = -1;
	}
}
